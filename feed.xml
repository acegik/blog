<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom" xml:lang="en">



  
  

<title type="text">Acegik's Blog</title>
<generator uri="https://github.com/mojombo/jekyll">Jekyll</generator>
<link rel="self" type="application/atom+xml" href="http:/vi/feed.xml" />
<link rel="alternate" type="text/html" href="http:/vi/" />
<updated>2014-08-28T00:29:34+07:00</updated>
<id>http:/vi/</id>
<author>
  <name>Phạm Ngọc Hùng</name>
  <uri>http:/vi/</uri>
  <email>pnhung177@drupalex.net</email>
</author>


<entry>
  <title type="html"><![CDATA[Tổng quan về IoC trong Spring Framework]]></title>
  <link rel="alternate" type="text/html" href="http:/vi/spring-framework/tong-quan-ve-ioc-trong-spring"/>
  <id>http:/vi/spring-framework/tong-quan-ve-ioc-trong-spring</id>
  <published>2014-08-24T00:00:00+07:00</published>
  <updated>2014-08-24T00:00:00-00:00</updated>
  
  <author>
    <name>Phạm Ngọc Hùng</name>
    <uri>http:/vi</uri>
    <email>pnhung177@drupalex.net</email>
  </author>
  <category scheme="http:/vi/tags/#Java" term="Java" /><category scheme="http:/vi/tags/#Spring%20Framework" term="Spring Framework" />
  <content type="html">
  
    &lt;p&gt;Spring Framework ra đời như là một chọn lựa, thay thế cho mô hình chuẩn EJB trong việc phát triển ứng dụng JavaEE đã đánh dấu một bước ngoặt trong lịch sử phát triển của Enterprise Java. Spring không ngừng phát triển và ngày càng phổ biến trong cộng đồng Java. Theo thống kê của &lt;a href=&quot;http://www.indeed.com/&quot;&gt;trang web tìm kiếm việc làm Indeed&lt;/a&gt; đến đầu năm 2014, tỉ lệ gia tăng việc làm trên Spring luôn cao hơn hẳn EJB.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-24-tong-quan-ve-ioc-trong-spring/spring-vs-ejb-jobgraph.png&quot; alt=&quot;Hình 1. Tỉ lệ gia tăng việc làm giữa Spring và EJB&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Một trong những thành phần chủ chốt, là nền tảng và tạo nên sức mạnh của Spring chính là IoC Container. IoC Container trong Spring được xây dựng dựa trên nguyên lý &lt;a href=&quot;http://en.wikipedia.org/wiki/Inversion_of_control&quot;&gt;Inversion of Control&lt;/a&gt; (đảo ngược điều khiển), đã xuất hiện khá lâu trong các mẫu hình thiết kế (Design Pattern), và được phổ biến rộng rãi nhờ &lt;a href=&quot;http://en.wikipedia.org/wiki/Dependency_inversion_principle&quot;&gt;Robert C. Martin&lt;/a&gt; và &lt;a href=&quot;http://martinfowler.com/bliki/InversionOfControl.html&quot;&gt;Martin Fowler&lt;/a&gt;. Để hiểu về Spring, trước tiên chúng ta cần hiểu khái niệm Inversion of Control là gì? Muốn vậy, chúng ta cần trả lời câu hỏi: Control (điều khiển) trong chương trình phần mềm là gì, và Inversion (sự đảo ngược) đối với điều khiển trong ngữ cảnh này được hiểu như thế nào.&lt;/p&gt;

&lt;p&gt;Mặc dù đã có một số bài viết tiếng Việt về chủ đề này, chẳng hạn như &lt;a href=&quot;http://congdongjava.com/forum/threads/inversion-of-control.1&quot;&gt;Inversion of control tại trang congdongjava.com&lt;/a&gt;, &lt;a href=&quot;http://javadevelopervietnam.blogspot.com/2011/03/tu-xay-dung-1-ao-nguoc-ieu-khien-ioc.html&quot;&gt;Tự xây dựng 1 framework đảo ngược điều khiển&lt;/a&gt;, &lt;a href=&quot;http://thietkewebno1.org/news/khai-niem-ve-inversion-of-control-ioc-va-dependency-injection-di-trong-spring/&quot;&gt;Khái niệm về Inversion of Control (IoC) và Dependency Injection (DI) trong Spring&lt;/a&gt; (hoặc các bạn có thể tìm kiếm thêm trên google), sau một thời gian suy nghĩ tôi cũng mạo muội viết lại và chia sẻ những hiểu biết của mình về IoC, mong những ai quan tâm cùng góp ý thảo luận để chúng ta hiểu rõ hơn về vấn đề này. &lt;/p&gt;

&lt;h2 id=&quot;control-flow-trong-ng-dng-l-g&quot;&gt;Control Flow trong ứng dụng là gì?&lt;/h2&gt;

&lt;p&gt;Khái niệm Control Flow (tạm dịch là luồng thực thi) được sử dụng cho trình tự thực hiện các câu lệnh, chỉ thị hoặc lời gọi hàm trong một chương trình, khi chương trình này thực thi.&lt;/p&gt;

&lt;p&gt;Do chương trình ngày càng phức tạp, nên người ta áp dụng phương pháp lập trình hướng đối tượng nhằm phân loại, chia tách các chức năng và gom thành các đối tượng. Người ta còn tạo dựng các thư viện tạo sẵn để có thể sử dụng lại. Luồng thực thi của chương trình, trong những tình huống cần xem xét ở mức tổng thể, không còn quan tâm đến các bước thực thi câu lệnh cụ thể nữa, mà chỉ xem xét đến quá trình gọi phương thức của các đối tượng trong ứng dụng cũng như các đối tượng của thư viện dựng sẵn.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-24-tong-quan-ve-ioc-trong-spring/oop_flow_of_control.png&quot; alt=&quot;Hai nhiệm vụ của người lập trình khi xây dựng ứng dụng&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Người lập trình, khi xây dựng ứng dụng từ đầu, đã thực hiện hai nhiệm vụ: trực tiếp điều khiển luồng thực thi của chương trình và xây dựng các chức năng để đáp ứng nghiệp vụ của ứng dụng. Thực tế, có nhiều chương trình hoặc bộ phận trong chương trình có luồng thực thi rất giống nhau, chẳng hạn phần tương tác với HTTP trong các ứng dụng web, phần unit testing trong các ứng dụng,… Việc trực tiếp tạo dựng và kiểm soát luồng thực thi của chương trình lặp đi lặp lại khi xây dựng nhiều ứng dụng sẽ làm mất nhiều công sức, chi phí, tạo ra sự nhàm chán và dễ phát sinh lỗi. Điều này tạo ra động lực cũng như môi trường để nguyên lý đảo ngược điều khiển nảy nở và phát triển.&lt;/p&gt;

&lt;h2 id=&quot;inversion-c-hiu-theo-ngha-g&quot;&gt;Inversion được hiểu theo nghĩa gì?&lt;/h2&gt;

&lt;p&gt;Một bạn đồng nghiệp của tôi trước đây đã hỏi tôi câu này, và tôi đã yêu cầu bạn ấy tìm kiếm trên Google các bài viết tiếng Anh lẫn tiếng Việt. Sau khi tìm kiếm và đọc cái bài viết, bạn ấy nói với tôi rằng vẫn còn rất mơ hồ và khó hiểu với những câu hỏi nghi vấn, đại loại như:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Đảo ngược điều khiển là đảo ngược cái gì: nếu hiểu điều khiển ở đây là luồng thực thi trong ứng dụng, thì đảo ngược điều khiển đâu phải là đảo ngược thứ tự thực thi? &lt;/li&gt;
  &lt;li&gt;Đảo ngược điều khiển có đồng nhất với khái niệm “bơm phụ thuộc” (Dependency Injection)? Nếu không đồng nhất thì chúng khác nhau ở chỗ nào?&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Tôi đã cố gắng tìm một vài ví dụ để giải thích một cách cụ thể. Tôi sẽ sử dụng lại ví dụ này để trình bày trong bài viết này.&lt;/p&gt;

&lt;h3 id=&quot;v-d-1-ng-dng-web-trong-java-vi-java-servlet&quot;&gt;Ví dụ 1: Ứng dụng web trong Java với Java Servlet&lt;/h3&gt;

&lt;p&gt;Hầu như tất cả chúng ta khi lập trình ứng dụng web bằng &lt;a href=&quot;http://docs.oracle.com/javaee/6/tutorial/doc/bnafd.html&quot;&gt;Java Servlet&lt;/a&gt; đều hình dung rõ ràng các bước lập trình như sau: Tạo lớp đối tượng kế thừa từ HttpServlet, nạp đè các phương thức doGet() - doPost(), sau đó đăng ký trong file cấu hình Deployment Descriptor tương ứng Servlet này với đường dẫn xác định. Lớp đối tượng Servlet chúng ta tạo ra sẽ được gọi đến khi có một truy vấn HTTP có đường dẫn “khớp” với đường dẫn khai báo trong Deployment Descriptor.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-24-tong-quan-ve-ioc-trong-spring/ioc_example_servlet.png&quot; alt=&quot;Đảo ngược điều khiển trong ứng dụng Servlet&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Và đôi khi chúng ta cũng đã tự hỏi: vậy ai kích hoạt ứng dụng chúng ta viết để đáp ứng mỗi khi có Http Request gửi đến? ai chịu trách nhiệm chuyển đổi các thông điệp Http (HTTP Request và HTTP response) thành các đối tượng Java (HttpServletRequest và HttpServletResponse) để truyền cho các hàm doGet(), doPost()? Câu trả lời rõ ràng và ngay lập tức: chính là Servlet Container.&lt;/p&gt;

&lt;h3 id=&quot;v-d-2-lp-trnh-unit-testing-bng-junit&quot;&gt;Ví dụ 2: Lập trình Unit Testing bằng JUnit&lt;/h3&gt;

&lt;p&gt;Trong quá trình phát triển các thành phần chức năng của ứng dụng, chúng ta thường áp dụng kiểm thử thành phần (&lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;Unit Testing&lt;/a&gt;) để đảm bảo chức năng đó vẫn chạy đúng trong suốt quá trình ứng dụng được mở rộng và phát triển thêm. Để tạo bộ Unit Test, chúng ta chỉ cần tạo một lớp đối tượng, định nghĩa các phương thức khởi tạo, phương thức kết thúc và các phương thức test. Sau đó, chúng ta chỉ việc chạy bộ test để kiểm thử. &lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-24-tong-quan-ve-ioc-trong-spring/ioc_example_unit_testing.png&quot; alt=&quot;Đảo ngược điều khiển trong quá trình chạy Unit Test&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Việc điều khiển trình tự thực thi các phương thức được giao cho thư viện bên ngoài đảm nhiệm (chẳng hạn như TestNG hoặc &lt;a href=&quot;http://junit.org/&quot;&gt;JUnit&lt;/a&gt;).&lt;/p&gt;

&lt;p&gt;Với hai ví dụ trên, chúng ta nhận thấy trong các ứng dụng đã có sự thay đổi vai trò: ứng dụng không còn ôm đồm vừa trực tiếp tạo dựng và kiểm soát luồng thực thi, vừa xây dựng chức năng nghiệp vụ. Việc kiểm soát luồng thực thi được tách khỏi chức năng nghiệp vụ và bị đẩy ra bên ngoài. Người lập trình đã ủy thác việc kiểm soát luồng thực thi ứng dụng cho một thành phần (thường là thư viện dựng sẵn) bên ngoài đảm nhiệm, chỉ còn tập trung vào chức năng chính của ứng dụng.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-24-tong-quan-ve-ioc-trong-spring/oop_app_ioc.png&quot; alt=&quot;Tách việc kiểm soát luồng thực thi ra khỏi ứng dụng&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Như vậy, khái niệm “đảo ngược” ở đây chính là chuyển nhiệm vụ kiểm soát lưu trình thực thi từ ứng dụng cho một thành phần chuyên trách (thường là một thư viện phần mềm khung - framework - dựng sẵn ở bên ngoài): ứng dụng chính chúng ta quan tâm phát triển không kiểm soát việc điều khiển luồng thực thi nữa, mà chỉ tập trung vào việc định nghĩa chức năng. Thư viện phần mềm khung chuyên trách kiểm soát điều khiển sẽ dựa trên mô tả trong cấu hình của ứng dụng để thay mặt ứng dụng điều phối luồng thực thi trong chương trình. Dễ dàng nhận thấy thư viện phần mềm khung này khác với các thư viện thông thường ở chỗ: thư viện thông thường cung cấp các chức năng và chờ được gọi đến, còn thư viện phần mềm khung tạo dựng luồng thực thi và gọi đến các chức năng của ứng dụng. Có lẽ sử dụng thuật ngữ “đảo ngược vai trò điều khiển luồng thực thi” thay cho “đảo ngược điều khiển” sẽ đầy đủ và phù hợp hơn cho khái niệm “Inversion of Control”. &lt;/p&gt;

&lt;h2 id=&quot;ti-liu-tham-kho&quot;&gt;Tài liệu tham khảo&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Control_flow&quot;&gt;Wikipedia - Control flow&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Inversion_of_control&quot;&gt;Wikipedia - Inversion of control&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://martinfowler.com/bliki/InversionOfControl.html&quot;&gt;Inversion of Control - Martin Fowler - 2005&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Spring_Framework&quot;&gt;Wikipedia - Spring Framework&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://congdongjava.com/forum/threads/inversion-of-control.1&quot;&gt;Inversion of control tại trang congdongjava.com&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://javadevelopervietnam.blogspot.com/2011/03/tu-xay-dung-1-ao-nguoc-ieu-khien-ioc.html&quot;&gt;Tự xây dựng 1 framework đảo ngược điều khiển&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://thietkewebno1.org/news/khai-niem-ve-inversion-of-control-ioc-va-dependency-injection-di-trong-spring/&quot;&gt;Khái niệm về Inversion of Control (IoC) và Dependency Injection (DI) trong Spring&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Unit_testing&quot;&gt;Wikipedia - Unit testing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://junit.org/&quot;&gt;Trang chủ JUnit&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javaee/6/tutorial/doc/bnafd.html&quot;&gt;Java Servlet Technology - The Java EE 6 Tutorial&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;


  
  &lt;p&gt;&lt;a href=&quot;http:/vi/spring-framework/tong-quan-ve-ioc-trong-spring&quot;&gt;Tổng quan về IoC trong Spring Framework&lt;/a&gt; was originally published by Phạm Ngọc Hùng at &lt;a href=&quot;http:/vi&quot;&gt;Acegik's Blog&lt;/a&gt; on August 24, 2014.&lt;/p&gt;</content>
</entry>


<entry>
  <title type="html"><![CDATA[Tổng quan về Java Concurrency]]></title>
  <link rel="alternate" type="text/html" href="http:/vi/java-concurrency/tong-quan-ve-java-concurrency"/>
  <id>http:/vi/java-concurrency/tong-quan-ve-java-concurrency</id>
  <published>2014-08-20T00:00:00+07:00</published>
  <updated>2014-08-20T00:00:00-00:00</updated>
  
  <author>
    <name>Phạm Ngọc Hùng</name>
    <uri>http:/vi</uri>
    <email>pnhung177@drupalex.net</email>
  </author>
  <category scheme="http:/vi/tags/#Java" term="Java" /><category scheme="http:/vi/tags/#Java%20Concurrency" term="Java Concurrency" /><category scheme="http:/vi/tags/#Java%20Multithread" term="Java Multithread" />
  <content type="html">
  
    &lt;p&gt;Tính toán đồng thời (&lt;a href=&quot;http://en.wikipedia.org/wiki/Concurrent_computing&quot; title=&quot;Concurrency Computing&quot;&gt;Concurrency computing&lt;/a&gt;) là một trong các đặc trưng nổi bật đã tạo nên thế mạnh của ngôn ngữ Java. Nhờ có tính năng này, chúng ta có thể tạo ra các chương trình bằng Java xử lý nhiều nhiệm vụ cùng lúc, đồng thời tận dụng thời gian nhàn rỗi để tăng tốc độ và hiệu năng của chương trình.&lt;/p&gt;

&lt;h2 id=&quot;tnh-ton-ng-thi-l-g&quot;&gt;Tính toán đồng thời là gì?&lt;/h2&gt;

&lt;p&gt;Tính toán đồng thời là quá trình xử lý nhiều nhiệm vụ được diễn ra trong cùng một khoảng thời gian. Khái niệm này trái ngược với tính toán tuần tự (Sequentially computing) là quá trình xử lý chỉ một nhiệm vụ trong mọi thời điểm, xong việc này mới bắt đầu xử lý việc tiếp theo. Một khái niệm khác có liên quan cũng cần phân biệt với Tính toán đồng thời, đó là khái niệm Tính toán song song (Parallel computing). Mặc dù cả hai khái niệm đều có ý nghĩa là xử lý nhiều nhiệm vụ cùng một lúc, tuy nhiên trong tính toán song song, hai lệnh thực thi cho hai nhiệm vụ khác nhau hoàn toàn độc lập với nhau và có thể xảy ra vào cùng thời điểm, trên hai máy tính hoặc bộ xử lý riêng biệt. Tính toán song song không thể thực hiện trên một máy tính chỉ có bộ xử lý đơn lõi được. Còn trong Tính toán đồng thời, về mặt tổng thể các nhiệm vụ diễn ra cùng nhau trong một khoảng thời gian chung, nhưng các lệnh xử lý các nhiệm vụ có khả năng phải thực thi xen kẽ nhau liên tiếp trên cùng một bộ vi xử lý đơn lõi trong một máy tính. Nói một cách đơn giản, Tính toàn đồng thời thực hiện nhiều nhiệm vụ cùng lúc, bằng những câu lệnh thực thi tuần tự.&lt;/p&gt;

&lt;p&gt;Mặc dù mọi sự so sánh đều khập khiễn, tuy nhiên để dễ hình dung về các phương thức tổ chức xử lý dữ liệu theo kiểu tuần tự, đồng thời hoặc song song, chúng ta sẽ xem xét ví dụ minh họa sau để so sánh giữa các khái niệm trình bày ở trên. Giả sử một nhà hàng cần chuẩn bị 3 món ăn cho một bàn ăn khách đặt. Tùy theo quy mô và ràng buộc về thời gian thực hiện, nhà hàng đó có thể thực hiện theo các cách sau:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Cách (A). Nhiều người nấu, mỗi người nấu một món, chế biến nguyên liệu và gia vị riêng biệt, thực hiện trong căn bếp riêng;&lt;/li&gt;
  &lt;li&gt;Cách (B). Nhiều người nấu, mỗi người nấu một món, nhưng chế biến nguyên liệu và gia vị chung, trong một bếp chung;&lt;/li&gt;
  &lt;li&gt;Cách (C). Một người nấu nhiều món cùng lúc, chế biến nguyên liệu và gia vị chung, trong một căn bếp;&lt;/li&gt;
  &lt;li&gt;Cách (D). Một người nấu nhiều món, mỗi thời điểm chỉ nấu một món, nấu xong món này mới thực hiện món khác.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-20-tong-quan-ve-java-concurrency/java-concurrency-4-cooking-models.png&quot; alt=&quot;Hình 1. Bốn cách thực hiện nấu bữa ăn gồm ba món ăn&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Nếu chúng ta tương ứng:&lt;/p&gt;

&lt;ul&gt;
  &lt;li&gt;Người nấu (đầu bếp) với chương trình phần mềm;&lt;/li&gt;
  &lt;li&gt;Nấu một món ăn tương ứng với một nhiệm vụ cần xử lý;&lt;/li&gt;
  &lt;li&gt;Nguyên liệu và gia vị tương ứng với dữ liệu (Tệp, kết nối mạng, …);&lt;/li&gt;
  &lt;li&gt;Nhà bếp tương ứng với máy tính hoặc bộ xử lý.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Ta sẽ thấy có sự tương đồng giữa các cách thức tổ chức quá trình xử lý dữ liệu trong lập trình với cách thức tổ chức nấu ăn cho một bữa ăn. Thật vậy, cách (A) tương ứng với việc sử dụng nhiều chương trình, mỗi chương trình chạy trên nhiều máy tính hoặc bộ xử lý khác nhau, sử dụng dữ liệu tách biệt (có thể trùng lặp) để thực hiện riêng nhiệm vụ được giao. Trong lập trình, đây chính là Tính toán song song (Parallel Computing) theo mô hình MPMD (Multiple Program, Multiple Data).&lt;/p&gt;

&lt;p&gt;Cách (B) tương ứng với cách tổ chức xử lý bằng cách sử dụng nhiều chương trình, mỗi chương trình xử lý một nhiệm vụ, tất cả chương trình sử dụng chung dữ liệu trên cùng một máy tính. Mô hình này chính là mô hình hệ điều hành đa nhiệm (Multitask Operating System) như Windows, Linux, MacOS mà chúng ta đã quen thuộc.&lt;/p&gt;

&lt;p&gt;Cách (C) tương ứng với Tính toán đồng thời, trong đó một chương trình xử lý nhiều nhiệm vụ đồng thời theo cách chia nhỏ từng nhiệm vụ thành các thao tác, thực thi các thao tác (không phân biệt của nhiệm vụ nào) xen kẽ nhau trong khoảng thời gian được phân bổ hợp lý. Khái niệm “đồng thời” không áp dụng cho từng thao tác (tương ứng với lệnh thực thi trong máy tính), tức là không thể thực hiện các thao tác cùng một lúc (kiểu như người nấu ăn vừa băm thịt, vừa thái hành). Ở đây, khái niệm “đồng thời” được áp dụng cho nguyên cả nhiệm vụ, hiểu theo nghĩa có hai hay nhiều nhiệm vụ cùng “đang” trong quá trình được xử lý, nhưng các hành động cụ thể thực hiện các nhiệm vụ được diễn ra xen kẽ tuần tự (nhưng không đồng thời).&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-20-tong-quan-ve-java-concurrency/java-concurrency-overview-one-chef-with-3-dishes1.png&quot; alt=&quot;Hình 2. Mô hình (C) tương ứng với Tính toán đồng thời (Concurrency) trong lập trình.&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Cách (D) tương ứng với lập trình tuần tự, trong đó chương trình xử lý tuần tự hết nhiệm vụ này rồi mới bắt đầu xử lý nhiệm vụ khác. Mỗi thời điểm chỉ có một nhiệm vụ đang được xử lý.&lt;/p&gt;

&lt;p&gt;Cũng với ví dụ trên, chúng ta có thể thấy cách (C) là dạng xử lý phổ biến nhất, giống như hàng triệu những người nội trợ hằng ngày nấu ăn theo cách này: một bữa ăn với nhiều món ăn, sử dụng chung nhiều nguyên liệu, và làm trong khuôn viên một căn bếp trong gia đình. Và đa số các bà nội trợ nấu nhiều món ăn “cùng lúc” để tận dụng thời gian nhàn rỗi lúc chờ đợi các món ăn được nấu chín cũng như kết hợp chuẩn bị nguyên liệu chung cho nhiều món ăn. Lưu ý các thao tác nấu ăn vẫn thực hiện tuần tự và xen kẽ lẫn nhau giữa các món.&lt;/p&gt;

&lt;h2 id=&quot;lp-trnh-ng-thi-trong-java&quot;&gt;Lập trình đồng thời trong Java&lt;/h2&gt;

&lt;p&gt;Trong &lt;a href=&quot;http://en.wikipedia.org/wiki/Java_concurrency&quot;&gt;Java&lt;/a&gt;, lập trình đồng thời được thiết kế theo mô hình Multithreading (xử lý đa luồng), trong đó chương trình bao gồm nhiều Thread (luồng), mỗi Thread chạy theo các bước thực thi lệnh của riêng mình, nhưng tất cả các luồng đều có khả năng truy cập được bất kỳ đối tượng và tài nguyên của chương trình. Người lập trình phải chịu trách nhiệm trong việc phân bổ và phối hợp chính xác giữa các Thread trong việc truy cập (đọc/ghi) các đối tượng và tài nguyên chung. Điều này cũng giống như người đầu bếp phân chia và phối hợp các thao tác chế biến nấu cho nhiều món ăn một cách nhịp nhàng, chính xác để tránh nhầm lẫn nguyên liệu và gia vị, đồng thời tận dụng được thời gian nhàn rỗi của dụng cụ và bếp để đạt hiệu quả cao nhất.&lt;/p&gt;

&lt;p&gt;Mỗi chương trình Java được chạy trên nền một máy ảo Java (&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_virtual_machine&quot;&gt;Java Virtual Machine&lt;/a&gt;). Máy ảo Java là dạng Máy ảo tiến trình (Process Virtual Machine), do đó mỗi chương trình Java là một tiến trình của hệ điều hành. Hàm main() trong chương trình Java sẽ tạo ra &lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html&quot;&gt;Thread&lt;/a&gt; mặc định. Một chương trình Java đơn giản chỉ có một Thread được tạo ra từ hàm main(). Máy ảo Java cho phép chương trình Java có thể tạo ra nhiều Thread khác. Nếu muốn xử lý đồng thời nhiều nhiệm vụ, người lập trình phải viết mã lệnh để hàm main() gọi đến để tạo ra các Thread khác.&lt;/p&gt;

&lt;p&gt;&lt;img src=&quot;http:/vi/images/2014-08-20-tong-quan-ve-java-concurrency/java-concurrency-one-process-with-3-threads1.png&quot; alt=&quot;Hình 3. Tiến trình Java với 3 Thread chạy đồng thời&quot; /&gt; &lt;/p&gt;

&lt;p&gt;Để tạo ra Thread, người lập trình cần thực hiện các bước sau:&lt;/p&gt;

&lt;ol&gt;
  &lt;li&gt;Định nghĩa lớp đối tượng chứa mã lệnh thực thi của Thread cần tạo, bằng một trong hai cách: a) tạo lớp con kế thừa trực tiếp từ lớp đối tượng java.lang.Thread; hoặc b) Tạo lớp đối tượng cài đặt Interface java.lang.Runnable.&lt;/li&gt;
  &lt;li&gt;Nạp đè (overriding) hàm run() kế thừa từ lớp java.lang.Thread hoặc giao diện java.lang.Runnable. Trong thân hàm run() viết mã lệnh cho nhiệm vụ mà mình muốn Thread thực hiện.&lt;/li&gt;
  &lt;li&gt;Bên trong hàm main (hoặc các phương thức mà hàm main() sẽ gọi đến), tạo đối tượng thể hiện (instance) của lớp Thread vừa tạo, sau đó gọi hàm start() để kích hoạt Thread.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Chương trình ví dụ minh họa được tạo ra như sau:&lt;/p&gt;

&lt;p&gt;Lớp đối tượng SimpleThread định nghĩa một Thread đơn giản, chỉ hiển thị thông báo ra màn hình cửa sổ console:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acegik&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;simplejavathreading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kn&quot;&gt;import&lt;/span&gt; &lt;span class=&quot;nn&quot;&gt;java.util.Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;SimpleThread&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;extends&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;private&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SimpleThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;this&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;k&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
    
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;run&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;()&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Thread#&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot; is running...&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;try&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;sleep&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;Random&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;().&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;nextInt&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5000&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;));&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;catch&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;InterruptedException&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;e&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{}&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Thread#&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;n&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;s&quot;&gt;&amp;quot; has been done!&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Lớp đối tượng App chứa hàm main() là hàm tạo Thread mặc định của chương trình Java. Bên trong hàm main() có chứa lệnh tạo ra 5 Thread con, sau đó kích hoạt những Thread con này thực thi:&lt;/p&gt;

&lt;div class=&quot;highlight&quot;&gt;&lt;pre&gt;&lt;code class=&quot;language-java&quot; data-lang=&quot;java&quot;&gt;&lt;span class=&quot;kn&quot;&gt;package&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;net&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;acegik&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;simplejavathreading&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt;

&lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;class&lt;/span&gt; &lt;span class=&quot;nc&quot;&gt;App&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
    &lt;span class=&quot;kd&quot;&gt;public&lt;/span&gt; &lt;span class=&quot;kd&quot;&gt;static&lt;/span&gt; &lt;span class=&quot;kt&quot;&gt;void&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;main&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;String&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;args&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[]&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;subThreads&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;5&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;];&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mainThread&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;Thread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;currentThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main thread&amp;#39;s name:&amp;quot;&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;+&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;mainThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;getName&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;());&lt;/span&gt;

        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;subThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;]&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;=&lt;/span&gt; &lt;span class=&quot;k&quot;&gt;new&lt;/span&gt; &lt;span class=&quot;nf&quot;&gt;SimpleThread&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Start sub-threads:&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
        &lt;span class=&quot;k&quot;&gt;for&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;kt&quot;&gt;int&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;=&lt;/span&gt;&lt;span class=&quot;mi&quot;&gt;0&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;&amp;lt;&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;subThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;length&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;;&lt;/span&gt; &lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;++)&lt;/span&gt; &lt;span class=&quot;o&quot;&gt;{&lt;/span&gt;
            &lt;span class=&quot;n&quot;&gt;subThreads&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;[&lt;/span&gt;&lt;span class=&quot;n&quot;&gt;i&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;].&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;start&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;();&lt;/span&gt;
        &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;

        &lt;span class=&quot;n&quot;&gt;System&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;out&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;.&lt;/span&gt;&lt;span class=&quot;na&quot;&gt;println&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;(&lt;/span&gt;&lt;span class=&quot;s&quot;&gt;&amp;quot;Main thread has been done!&amp;quot;&lt;/span&gt;&lt;span class=&quot;o&quot;&gt;);&lt;/span&gt;
    &lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;
&lt;span class=&quot;o&quot;&gt;}&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;

&lt;p&gt;Các bạn có thể tải mã nguồn đầy đủ của &lt;a href=&quot;https://github.com/pnhung177/java-simple-threading&quot;&gt;ví dụ minh họa&lt;/a&gt; để chạy thử.&lt;/p&gt;

&lt;h2 id=&quot;ti-liu-tham-kho&quot;&gt;Tài liệu tham khảo&lt;/h2&gt;

&lt;ol&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Concurrent_computing&quot; title=&quot;Concurrency Computing&quot;&gt;Wikipedia - Concurrency Computing&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_concurrency&quot;&gt;Wikipedia - Java concurrency&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://en.wikipedia.org/wiki/Java_virtual_machine&quot;&gt;Wikipedia - Java Virtual Machine&lt;/a&gt;&lt;/li&gt;
  &lt;li&gt;&lt;a href=&quot;http://docs.oracle.com/javase/7/docs/api/java/lang/Thread.html&quot;&gt;Oracle JavaSE 7 API Reference Documentation - Class Thread&lt;/a&gt;&lt;/li&gt;
&lt;/ol&gt;


  
  &lt;p&gt;&lt;a href=&quot;http:/vi/java-concurrency/tong-quan-ve-java-concurrency&quot;&gt;Tổng quan về Java Concurrency&lt;/a&gt; was originally published by Phạm Ngọc Hùng at &lt;a href=&quot;http:/vi&quot;&gt;Acegik's Blog&lt;/a&gt; on August 20, 2014.&lt;/p&gt;</content>
</entry>

</feed>
